<?php

require_once 'Mail/mime.php';

/**
 * Class MailProcessor.
 *
 * Handles eml generation.
 */
class CRM_Emailfiling_Service_MailProcessor {

  /**
   * Email data (comes from hook_civicrm_alterMailParams()).
   *
   * @var array
   */
  private $message;

  /**
   * EmlGenerator constructor.
   *
   * @param array $message
   *   Email data (comes from hook_civicrm_alterMailParams()).
   */
  public function __construct(array $message) {
    $message['timestamp'] = $message['timestamp'] ?? time();
    $this->message = $message;
  }

  /**
   * Attaches email as .eml file to activity.
   *
   * @param int $activityId
   *   Activity id.
   * @param string|null $eml
   *   (Optional)Contents of eml file.
   * @param array|null $message
   *   (Optional) Email data. If set to NULL then $this->message would be used.
   *
   * @return array|false
   *   Attached file entity data, empty array or FALSE in case of error.
   *
   * @throws \CiviCRM_API3_Exception
   *   An exception generated by civicrm_api3().
   */
  public function attachEmlToActivity($activityId, $eml = NULL, $message = NULL) {
    if (!$activityId) {
      return FALSE;
    }

    $eml = $eml ?? $this->generateEml($message);
    $result = civicrm_api3('Attachment', 'create', [
      'sequential' => 1,
      'entity_table' => 'civicrm_activity',
      'entity_id' => $activityId,
      'mime_type' => 'message/rfc822',
      'name' => $this->generateEmlFileName($message),
      'content' => $eml,
    ]);

    // Set file type to attached file.
    // (The file_type_id db table column is always NULL and not used in civicrm
    // at all. But we need to set some flag to differentiate original email from
    // other attached files (and disable edit/delete for this file later), so we
    // will use that field for this purpose and just set 1 as a value)
    if (!empty($result['id'])) {
      civicrm_api3('File', 'create', [
        'id' => $result['id'],
        'file_type_id' => $this->getOriginalEmailFileTypeId(),
      ]);
    }

    return $result['values'][0] ?? [];
  }

  /**
   * Generates name for eml file.
   *
   * @param array|null $message
   *   (Optional) Email data. If set to NULL then $this->message would be used.
   *
   * @return string
   *   File name (including extension) for original message eml file.
   */
  private function generateEmlFileName($message = NULL) {
    $message = $message ?? $this->message;
    $res = date('Ymd_Hi_', $this->param('timestamp', $message) ?? time())
      . preg_replace('!\W+!', '', trim(strtolower($this->param('subject', $message))));
    // Avoid too long file names.
    $res = substr($res, 0, 128) . '.eml';

    return $res;
  }

  /**
   * Generates eml file from email data.
   *
   * @param array|null $message
   *   (Optional) Email data. If set to NULL then $this->message would be used.
   *
   * @return string
   *   Eml file contents.
   */
  private function generateEml($message = NULL) {
    $email = $this->paramsToMime($message);
    return $email->getMessage();
  }

  /**
   * Creates email object from email data.
   *
   * This method is almost an exact copy of convertMailParamsToMime()
   * method of MailParams class in flexmailer extension.
   *
   * @param array|null $params
   *   (Optional) Email data. If set to NULL then $this->message would be used.
   *
   * @return \Mail_mime
   *   Email as Mail_mime object.
   */
  private function paramsToMime($params = NULL) {
    $params = $params ?? $this->message;
    // The general assumption is that key-value pairs in $mailParams should
    // pass through as email headers, but there are several special-cases
    // (e.g. 'toName', 'toEmail', 'text', 'html', 'attachments', 'headers').

    $message = new \Mail_mime("\n");

    // Add date parameter.
    $params['Date'] = $params['Date'] ?? date(DATE_RFC822, $params['timestamp'] ?? time());
    if (isset($params['timestamp'])) {
      unset($params['timestamp']);
    }

    // Consolidate: 'toName' and 'toEmail' should be 'To'.
    $toName = trim($params['toName']);
    $toEmail = trim($params['toEmail']);
    if ($toName == $toEmail || strpos($toName, '@') !== FALSE) {
      $toName = NULL;
    }
    else {
      $toName = \CRM_Utils_Mail::formatRFC2822Name($toName);
    }
    unset($params['toName']);
    unset($params['toEmail']);
    $params['To'] = $toEmail ? "$toName <$toEmail>" : $params['To'];

    // Apply the other fields.
    foreach ($params as $key => $value) {
      if (empty($value)) {
        continue;
      }

      switch ($key) {
        case 'text':
          $message->setTxtBody($params['text']);
          break;

        case 'html':
          $message->setHTMLBody($params['html']);
          break;

        case 'attachments':
          foreach ($params['attachments'] as $fileID => $attach) {
            $message->addAttachment($attach['fullPath'],
              $attach['mime_type'],
              $attach['cleanName']
            );
          }
          break;

        case 'headers':
          $message->headers($value);
          break;

        default:
          $message->headers(array($key => $value), TRUE);
      }
    }

    \CRM_Utils_Mail::setMimeParams($message);

    return $message;
  }

  /**
   * Returns some parameter/item from message data.
   *
   * Normally we can get data in a simple way like this: $message['subject'],
   * but as data may come from different sources, array keys may have different
   * case, e.g: $message['Subject'].
   * So we can use this method to be sure to fetch data any way.
   * However it may not work if key name consists of multiple words like
   * $message['MagicHeader'], in this case it's recommended to use correct case
   * right away.
   *
   * @param string $name
   *   Item name/key.
   * @param array|null $message
   *   (Optional) Email data. If set to NULL then $this->message would be used.
   *
   * @return mixed|null
   *   Item from message array, or NULL if not found.
   */
  private function param($name, $message = NULL) {
    $message = $message ?? $this->message;

    if (isset($message[$name])) {
      return $message[$name];
    }

    $name = strtolower($name);
    if (isset($message[$name])) {
      return $message[$name];
    }

    $name = ucfirst($name);

    return $message[$name] ?? NULL;
  }

  /**
   * Returns id of 'Original email' file type.
   *
   * @return int
   *   The id of 'Original email' file type.
   */
  private function getOriginalEmailFileTypeId() {
    // The file_type_id column exists in civicrm_file db table, but never used
    // and there are no actual types defined. So let's return a value directly.
    return 1;
  }

}
